## サーキットブレーカーパターンを使用する

リモートサービス呼出しをタイムアウト値に依存させるよりも、サーキットブレーカーパターンと呼ばれるものを使う方がより良いアプローチです。
このソフトウェアパターンは、まさに家の中のブレーカーのように動作します。
ブレーカーが上がっているとき電気は流れますが、一度ブレーカーが落ちるとブレーカーが上げられるまで電気は全く流れなくなります。
同じ要領で、サービスが応答していないことを検知すると、ソフトウェアのブレーカが落ちて、そのサービスへのリクエストを遮断します。
サービスが応答状態になればブレーカーは上がり、リクエストが通ることができるようになります。

図2-3に、サーキットブレーカーパターンがどのように動作するのかを記載します。
サーキットブレーカーは絶えずリモートサービスを監視して、サービスが生きていること、応答していることを確認します（詳細は後述）。
サービスが応答状態にある限りはブレーカーは上がった状態で、リクエストの通過を許可します。
リモートサービスが突然応答しなくなると、サーキットブレーカーが落ちます。
このようにして、サービスが再び応答状態になるまで、リクエストが通過するのを防止するのです。
しかしながら、家の中のブレーカーとは違って、ソフトウェアのブレーカーはサービスの監視を継続し、リモートサービスが再度応答状態になったら、自身を上げることができます。

![サーキットブレーカーパターン](./img/2-3.png)  
図2-3. サーキットブレーカーパターン

実装に従い、サービスコンシューマは常にサーキットブレーカーが落ちているのか、上がっているのかを最初に確認します。
サービスコンシューマがリクエスト経路にサーキットブレーカーがあるかを知る必要をなくすために、
この処理をインターセプタパターンによって実施させることも可能です。
いずれにしても、タイムアウト値の分だけ待つよりもサービスコンシューマがサービスが応答していないことが
直ちに分かることがタイムアウト値に勝るサーキットブレーカーパターンの重要な利点です。
前述の例において、タイムアウト値の代わりにサーキットブレーカーが使用されていれば、
取引実行サービスが応答していないことが分かるまでに10秒（10000ミリ秒）待たなければならないものが数ミリ秒で知ることができるでしょう。